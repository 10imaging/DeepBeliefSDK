<html>
  <head>
    <title>Jetpac Deep Belief Demo</title>
    <script type="text/javascript" src="underscore.js"></script>
    <script type="text/javascript" src="glMatrix.js"></script>
    <script type="text/javascript" src="webgl-debug.js"></script>
    <script type="text/javascript" src="webgl.js"></script>
    <script type="text/javascript" src="jpcnn.js"></script>
    <style>
      .image {
        float: left;
      }
      .labels-container {
        float: left;
        width: 400px;
      }
    </style>
  </head>
  <body>
    <h2>Jetpac's Deep Belief in Javascript</h2>

    <video style="visibility: hidden;" id="live" autoplay></video>

    <div>
      Choose an image file to analyze:
      <input type="file" id="file-input">
    </div>

    <canvas class="image" id="image-preview"></canvas>
    <div class="labels-container">
    </div>
    <div class="time"></div>

    <canvas class="gl-test" id="gl-test"></canvas>

    <script type="text/javascript">
      var video = document.getElementById("live");

      var network = new Network('data/example_networks/homebrewed_compressed.ntwk', function() {
        //testDogImage();
      });

//      navigator.webkitGetUserMedia({video: true},
//          function(stream) {
//            video.src = window.webkitURL.createObjectURL(stream)
//          },
//          function(err) {
//            console.log("Unable to get video stream!")
//          }
//      );

      var dogImage;
      function testDogImage() {
        dogImage = document.createElement('img');
        dogImage.onload = function() {
          classifyImage(dogImage, dogImage.width, dogImage.height);
        };
        dogImage.src = 'data/dog.jpg';
      }

      function classifyImage(image, width, height) {

        var destSize = 256;

        var canvasElement = document.getElementById('image-preview');//document.createElement("canvas");
        canvasElement.width = destSize;
        canvasElement.height = destSize;

        var sourceX;
        var sourceY;
        var sourceSize;
        if (width > height) {
          sourceSize = height;
          sourceX = ((width - height) / 2);
          sourceY = 0;
        } else {
          sourceSize = width;
          sourceX = 0;
          sourceY = ((height - width) / 2);
        }

        var canvas = canvasElement.getContext("2d");
        canvas.drawImage(image, sourceX, sourceY, sourceSize, sourceSize, 0, 0, destSize, destSize);

        var imageData = canvas.getImageData(0, 0, destSize, destSize);

        var inputBuffer = new Buffer([destSize, destSize, 3]);
        for (var y = 0; y < destSize; y += 1) {
          for (var x = 0; x < destSize; x += 1) {
            var imageOffset = (y * destSize * 4) + (x * 4);
            var bufferOffset = (y * destSize * 3) + (x * 3);
            inputBuffer._data[bufferOffset + 0] = imageData.data[imageOffset + 0];
            inputBuffer._data[bufferOffset + 1] = imageData.data[imageOffset + 1];
            inputBuffer._data[bufferOffset + 2] = imageData.data[imageOffset + 2];
          }
        }
        inputBuffer.setName('inputBuffer');
        console.log(inputBuffer);

        var startTime = new Date().getTime();
        var results = network.classifyImage(inputBuffer, false, 0);
        var endTime = new Date().getTime();
        var duration = (endTime - startTime);

        var topResults = _.select(results, function(prediction) {
          return (prediction.value > 0.01);
        });
        topResults = topResults.sort(function(a, b) { return (b.value - a.value); });
        topResults = _.first(topResults, 10);
        var labelsContainer = document.getElementsByClassName('labels-container')[0];
        labelsContainer.innerHTML = '';
        if (topResults.length > 0) {
          _.each(topResults, function(prediction) {
            var score = Math.round(prediction.value * 100);
            var label = document.createElement('div');
            label.className = 'label';
            label.innerHTML = prediction.label + ' - ' + score + '%';
            labelsContainer.appendChild(label);
          });
        } else {
          var label = document.createElement('div');
          label.className = 'label';
          label.innerHTML = 'No labels found';
          labelsContainer.appendChild(label);
        }
        var timeContainer = document.getElementsByClassName('time')[0];
        timeContainer.innerHTML = 'Took ' + duration + 'ms';
      }

      window.onload = function() {
        var fileInput = document.getElementById('file-input');
        fileInput.addEventListener('change', function(e) {
          var file = fileInput.files[0];
          var imageType = /image.*/;

          if (file.type.match(imageType)) {
            var reader = new FileReader();
            reader.onload = function(e) {
              var image = new Image();
              image.src = reader.result;
              classifyImage(image, image.width, image.height);
            }
            reader.readAsDataURL(file); 
          } else {
            alert('File type "' + file.type + '" can\'t be read as an image');
          }
        });

        var webglCanvas = document.getElementById('gl-test');

        var width = 400;
        var height = 400;
        var webgl = new WebGL({
          canvas: webglCanvas,
          width: width,
          height: height
        });

        var testVertexShader = '' +
          '  precision mediump float;\n' +
          '  uniform mat4 modelView;\n' +
          '  uniform mat4 projection;\n' +
          '\n' +
          '  attribute vec2 vertexPosition;\n' +
          '  attribute vec2 texCoords;\n' +
          '  varying vec2 outTexCoord;\n' +
          '\n' +
          '  void main(void) {\n' +
          '    gl_Position = projection * modelView * vec4(vertexPosition, 0.0, 1.0);\n' +
          '    outTexCoord = texCoords;\n' +
          '  }\n';

        var testFragmentShader = '' +
          '  precision mediump float;\n' +
          '  varying vec2 outTexCoord;\n' +
          '  void main(void) {\n' +
          '    vec2 texCoord = outTexCoord;\n' +
          '    gl_FragColor = vec4(0, 1, 0, 1);\n' +
          '  }\n';

        var testProgram = webgl.createShaderProgram(testVertexShader, testFragmentShader);

        var viewBottom = 0;
        var viewTop = height;
        var viewLeft = 0;
        var viewRight = width;

        var vertices = [
          viewRight,  viewBottom,   viewRight,  viewBottom,
          viewLeft,   viewBottom,   viewLeft,   viewBottom,
          viewRight,  viewTop,      viewRight,  viewTop,
          viewLeft,   viewTop,      viewLeft,   viewTop
        ];
        var vertexBuffer = webgl.createVertexBuffer(vertices, 2, 2);

        var framebufferTexture = webgl.createEmptyTexture(width, height);

        webgl.renderIntoTexture(framebufferTexture);

        webgl.setOneToOneProjection();
        webgl.clearScreen(1, 1, 0, 1);
//        webgl.enable('BLEND');
//        webgl.blendFunc('ONE', 'ONE_MINUS_SRC_ALPHA');

        webgl.drawVertexBuffer({
          shader: testProgram,
          vertexBuffer: vertexBuffer,
          uniformFloats: {}
        });

        var pixelData = webgl.readRenderedData();
        console.log(pixelData);
      }

    </script>
  </body>
</html>