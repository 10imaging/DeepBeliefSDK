<html>
  <head>
    <title>Jetpac Deep Belief Demo</title>
    <script type="text/javascript" src="underscore.js"></script>
    <script type="text/javascript" src="glMatrix.js"></script>
    <script type="text/javascript" src="webgl-debug.js"></script>
    <script type="text/javascript" src="webgl.js"></script>
    <script type="text/javascript" src="jpcnn.js"></script>
    <style>
      .image {
        float: left;
      }
      .labels-container {
        float: left;
        width: 400px;
      }
    </style>
  </head>
  <body>
    <h2>Jetpac's Deep Belief in Javascript</h2>

    <video style="visibility: hidden;" id="live" autoplay></video>

    <div>
      Choose an image file to analyze:
      <input type="file" id="file-input">
    </div>

    <canvas class="image" id="image-preview"></canvas>
    <div class="labels-container">
    </div>
    <div class="time"></div>

    <canvas class="gl-test" id="gl-test"></canvas>

    <script type="text/javascript">
      var video = document.getElementById("live");

      var network = new Network('data/example_networks/homebrewed_compressed.ntwk', function() {
        //testDogImage();
      });

//      navigator.webkitGetUserMedia({video: true},
//          function(stream) {
//            video.src = window.webkitURL.createObjectURL(stream)
//          },
//          function(err) {
//            console.log("Unable to get video stream!")
//          }
//      );

      var dogImage;
      function testDogImage() {
        dogImage = document.createElement('img');
        dogImage.onload = function() {
          classifyImage(dogImage, dogImage.width, dogImage.height);
        };
        dogImage.src = 'data/dog.jpg';
      }

      function classifyImage(image, width, height) {

        var destSize = 256;

        var canvasElement = document.getElementById('image-preview');//document.createElement("canvas");
        canvasElement.width = destSize;
        canvasElement.height = destSize;

        var sourceX;
        var sourceY;
        var sourceSize;
        if (width > height) {
          sourceSize = height;
          sourceX = ((width - height) / 2);
          sourceY = 0;
        } else {
          sourceSize = width;
          sourceX = 0;
          sourceY = ((height - width) / 2);
        }

        var canvas = canvasElement.getContext("2d");
        canvas.drawImage(image, sourceX, sourceY, sourceSize, sourceSize, 0, 0, destSize, destSize);

        var imageData = canvas.getImageData(0, 0, destSize, destSize);

        var inputBuffer = new Buffer([destSize, destSize, 3]);
        for (var y = 0; y < destSize; y += 1) {
          for (var x = 0; x < destSize; x += 1) {
            var imageOffset = (y * destSize * 4) + (x * 4);
            var bufferOffset = (y * destSize * 3) + (x * 3);
            inputBuffer._data[bufferOffset + 0] = imageData.data[imageOffset + 0];
            inputBuffer._data[bufferOffset + 1] = imageData.data[imageOffset + 1];
            inputBuffer._data[bufferOffset + 2] = imageData.data[imageOffset + 2];
          }
        }
        inputBuffer.setName('inputBuffer');
        console.log(inputBuffer);

        var startTime = new Date().getTime();
        var results = network.classifyImage(inputBuffer, false, 0);
        var endTime = new Date().getTime();
        var duration = (endTime - startTime);

        var topResults = _.select(results, function(prediction) {
          return (prediction.value > 0.01);
        });
        topResults = topResults.sort(function(a, b) { return (b.value - a.value); });
        topResults = _.first(topResults, 10);
        var labelsContainer = document.getElementsByClassName('labels-container')[0];
        labelsContainer.innerHTML = '';
        if (topResults.length > 0) {
          _.each(topResults, function(prediction) {
            var score = Math.round(prediction.value * 100);
            var label = document.createElement('div');
            label.className = 'label';
            label.innerHTML = prediction.label + ' - ' + score + '%';
            labelsContainer.appendChild(label);
          });
        } else {
          var label = document.createElement('div');
          label.className = 'label';
          label.innerHTML = 'No labels found';
          labelsContainer.appendChild(label);
        }
        var timeContainer = document.getElementsByClassName('time')[0];
        timeContainer.innerHTML = 'Took ' + duration + 'ms';
      }

      window.onload = function() {
        var fileInput = document.getElementById('file-input');
        fileInput.addEventListener('change', function(e) {
          var file = fileInput.files[0];
          var imageType = /image.*/;

          if (file.type.match(imageType)) {
            var reader = new FileReader();
            reader.onload = function(e) {
              var image = new Image();
              image.src = reader.result;
              classifyImage(image, image.width, image.height);
            }
            reader.readAsDataURL(file); 
          } else {
            alert('File type "' + file.type + '" can\'t be read as an image');
          }
        });

        var gpuCalculator = new GPUCalculator();

        var testFragmentShader = '' +
          '  precision mediump float;\n' +
          '  varying vec2 outTexCoord;\n' +
          '  void main(void) {\n' +
          '    vec2 texCoord = outTexCoord;\n' +
          '    gl_FragColor = vec4(0.333333, 1, 0, 1);\n' +
          '  }\n';

        var testOutput = gpuCalculator.applyShader({
          shaderText: testFragmentShader,
          width: 300,
          height: 300
        });

        var halveFragmentShader = '' +
          '  precision mediump float;\n' +
          '  varying vec2 outTexCoord;\n' +
          '  uniform sampler2D input0;\n' +
          '  uniform vec2 input0Scale;\n' +
          '  uniform vec2 input0Offset;\n' +
          '  void main(void) {\n' +
          '    vec2 texCoord0 = outTexCoord;\n' +
          '    texCoord0 += input0Offset;\n' +
          '    texCoord0 *= input0Scale;\n' +
          '    vec4 inputColor = texture2D(input0, texCoord0);\n' +
          '    gl_FragColor = inputColor * 0.25;\n' +
          '  }\n';

        var halvedOutput = gpuCalculator.applyShader({
          shaderText: halveFragmentShader,
          inputBuffers: { input0: testOutput },
          width: 300,
          height: 300
        });

        var result = gpuCalculator.getResult(testOutput);
        console.log('result = ' + result[0] + ', ' + result[1] + ', ' + result[2] + ', ' + result[3]);
        console.log('result[1196] = ' + result[1196] + ', ' + result[1197] + ', ' + result[1198] + ', ' + result[1199]);

        gpuCalculator.deleteBuffer(testOutput);
        gpuCalculator.deleteBuffer(halvedOutput);

        testGemm();
      }

      function testGemm() {
        var weights;
        var input;
        var expectedOutput;
        delayedBufferFromFileAtURL('data/gemm_test/a.buff', function(buffer) {
          weights = buffer;
          delayedBufferFromFileAtURL('data/gemm_test/b.buff', function(buffer) {
            input = buffer;
            delayedBufferFromFileAtURL('data/gemm_test/output.buff', function(buffer) {
              expectedOutput = buffer;
              doTestGemm(weights, input, expectedOutput);
            });
          });
        });
      }

      function doTestGemm(weights, input, expectedOutput) {

        var inputDims = input._dims;
        // We're expecting (# of images, # of values)
        console.assert(inputDims._dims.length == 2);

        var imageCount = inputDims._dims[0];
        var inputValuesCount = inputDims._dims[1];

        var weightsDims = weights._dims;
        // We're expecting (# of values in input, # of output channels)
        console.assert(inputDims._dims.length == 2);
        console.assert(weightsDims._dims[0] == inputValuesCount);
        var outputChannels = weightsDims._dims[1];

        var outputDims = new Dimensions(imageCount, outputChannels);
        var output = new Buffer(outputDims);
        output.setName('output');

        var m = outputChannels;
        var n = input._dims._dims[0];
        var k = input._dims._dims[1];
        var alpha = 1.0;
        var lda = m;
        var ldb = k;
        var ldc = m;
        var beta = 0.0;
        var outputData = glGemm(
          m,
          n,
          k,
          alpha,
          weights._data,
          lda,
          input._data,
          ldb,
          beta,
          output._data,
          ldc
        );

        var cpuOutput = new Buffer(outputDims);
        cpuOutput.setName('output');
        matrixGemm(
          m,
          n,
          k,
          alpha,
          weights._data,
          lda,
          input._data,
          ldb,
          beta,
          cpuOutput._data,
          ldc
        );

        output._data = outputData;
        output.areAllClose(cpuOutput);
        console.log(output);
        console.log(cpuOutput);
      }

      var gemmShader = "                     \n\
        precision mediump float;                                      \n\
        varying vec2 outTexCoord;                                     \n\
        uniform sampler2D a;                                          \n\
        uniform vec2 aScale;                                          \n\
        uniform sampler2D b;                                          \n\
        uniform vec2 bScale;                                          \n\
        uniform sampler2D c;                                          \n\
        uniform vec2 cScale;                                          \n\
        uniform float alpha;                                          \n\
        uniform float beta;                                           \n\
        uniform float k;                                              \n\
        void main(void) {                                             \n\
          vec2 texCoord = outTexCoord;                                \n\
          float i = texCoord.x;                                       \n\
          float j = texCoord.y;                                       \n\
          vec2 cCoords = vec2(i, j) * cScale;                         \n\
          float cValue;                                               \n\
          if (beta != 0.0) {                                          \n\
            cValue = texture2D(c, cCoords).r;                         \n\
          } else {                                                    \n\
            cValue = 0.0;                                             \n\
          }                                                           \n\
          float total = 0.0;                                          \n\
          for (int l = 0; l < 100000; l += 1) {                            \n\
            if (l >= int(k)) {                                             \n\
              break;                                                  \n\
            }                                                         \n\
            float lCoord = (float(l) + 0.5);                          \n\
            vec2 aCoords = vec2(i, lCoord) * aScale;                  \n\
            float aValue = texture2D(a, aCoords).r;                   \n\
            vec2 bCoords = vec2(lCoord, j) * bScale;                  \n\
            float bValue = texture2D(b, bCoords).r;                   \n\
            total += (aValue * bValue);                               \n\
          }                                                           \n\
          gl_FragColor.r = (alpha * total) + (beta * cValue);         \n\
          //gl_FragColor = vec4(k, 1, 0, 3);                        \n\
        }                                                             \n\
      ";

      function glGemm(
        m,
        n,
        inputK,
        alpha,
        a,
        lda,
        b,
        ldb,
        inputBeta,
        c,
        ldc) {

        var gpuCalculator = new GPUCalculator();

        var aFullDims = new Dimensions(inputK, m, 1);
        var bFullDims = new Dimensions(n, inputK, 1);
        var cDims = new Dimensions(n, m, 1);

        var maxTextureSize = 4096;
        var use4x = false;

        var kStep = 0;
        var currentK = inputK;
        var originK = (kStep * maxTextureSize);
        var beta = inputBeta;

        var aDims;
        var bDims;
        if (use4x) {
          aDims = new Dimensions(currentK, (m / 4), 4);
          bDims = new Dimensions(n, (currentK / 4), 4);
        } else {
          aDims = new Dimensions(currentK, m, 1);
          bDims = new Dimensions(n, currentK, 1);
        }

        var aBuffer = gpuCalculator.createBuffer(aDims._dims[1], aDims._dims[0], aDims._dims[2], a);
        var bBuffer = gpuCalculator.createBuffer(bDims._dims[1], bDims._dims[0], bDims._dims[2], b);
        var previousCBuffer = gpuCalculator.createBuffer(cDims._dims[1], cDims._dims[0], cDims._dims[2], null);

        var uniforms = {
          'alpha': alpha,
          'beta': beta,
          'k': currentK
        };
        var inputBuffers = {
          'a': aBuffer,
          'b': bBuffer,
          'c': previousCBuffer
        };

        var outputCBuffer = gpuCalculator.applyShader({
          shaderText: gemmShader,
          inputBuffers: inputBuffers,
          uniforms: uniforms,
          width: cDims._dims[1],
          height: cDims._dims[0]
        });

        var output = gpuCalculator.getResult(outputCBuffer, 1);
        console.log('output = ' + output[0] + ', ' + output[1] + ', ' + output[2] + ', ' + output[3]);

        gpuCalculator.deleteBuffer(aBuffer);
        gpuCalculator.deleteBuffer(bBuffer);
        gpuCalculator.deleteBuffer(previousCBuffer);
        gpuCalculator.deleteBuffer(outputCBuffer);

        return output;
      }

    </script>
  </body>
</html>